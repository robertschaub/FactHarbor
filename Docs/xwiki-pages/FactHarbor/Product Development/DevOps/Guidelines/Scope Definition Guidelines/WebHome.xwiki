= Boundary Definition Guidelines: EvidenceScope vs ClaimBoundary =

**Version**: 3.0.0-cb
**Date**: 2026-02-16
**Audience**: Developers, Prompt Engineers
**Related**: [[Terminology>>FactHarbor.Product Development.Specification.Reference.Terminology.WebHome]], AGENTS.md

----

== Table of Contents ==

1. [[Quick Reference>>||anchor="H1.QuickReference"]]
1. [[EvidenceScope>>||anchor="H2.EvidenceScope"]]
1. [[ClaimBoundary>>||anchor="H3.ClaimBoundary"]]
1. [[Decision Tree>>||anchor="H4.DecisionTree"]]
1. [[Common Mistakes>>||anchor="H5.CommonMistakes"]]
1. [[Code Examples>>||anchor="H6.CodeExamples"]]

----

== 1. Quick Reference ==

=== TL;DR ===

|= Concept |= Purpose |= Scope |= Cardinality
| **EvidenceScope** | Source methodology metadata | Per-evidence-item | Required (1 per item)
| **ClaimBoundary** | Evidence-emergent grouping | Per-analysis | 1-5 per analysis

**Rule of Thumb**:
* **EvidenceScope** = "What methodology/boundaries does THIS source use?"
* **ClaimBoundary** = "Which evidence items can be clustered together by compatible EvidenceScopes?"

=== When in Doubt ===

**Use EvidenceScope** (always):
* EVERY evidence item MUST have an EvidenceScope
* Describes source's methodology, temporal period, boundaries, geography
* Mandatory fields: ##methodology##, ##temporal##

**Use ClaimBoundary** (determined by pipeline):
* ClaimBoundaries emerge from clustering compatible EvidenceScopes (Stage 3)
* NOT pre-created from user input
* Grouping is based on congruence assessment (methodology + temporal + boundaries + geographic compatibility)

----

== 2. EvidenceScope ==

=== 2.1 Definition ===

**EvidenceScope** = Per-evidence-item metadata describing the source's **methodology, temporal period, boundaries, and geography**.

**Location**: Attached to every ##EvidenceItem## object (MANDATORY, not optional)

{{code language="typescript"}}
interface EvidenceItem {
  id: string;                               // EV_001, EV_002, ...
  statement: string;                        // The evidence statement
  category: string;
  sourceId: string;
  sourceUrl: string;
  sourceExcerpt: string;

  // REQUIRED: Source methodology metadata
  evidenceScope: {
    name: string;                           // E.g., "Methodology A Analysis"
    methodology: string;                    // REQUIRED - The analytical approach
    temporal: string;                       // REQUIRED - Time period of source data
    boundaries?: string;                    // Optional - What is included/excluded
    geographic?: string;                    // Optional - Geographic scope
    sourceType?: SourceType;                // Optional - peer_reviewed_study, etc.
    additionalDimensions?: Record<string, string>; // Optional - domain-specific data
  };

  scopeQuality: "complete" | "partial" | "incomplete"; // LLM-assessed
  claimBoundaryId?: string;                 // Assigned during CLUSTER stage
  relevantClaimIds: string[];               // Which claims this evidence relates to
  isDerivative: boolean;                    // Derives from another source's study
  derivedFromSourceUrl?: string;            // URL of original source (optional)
}
{{/code}}

=== 2.2 Purpose ===

**Primary Use**: Congruence assessment for ClaimBoundary clustering

When evidence is extracted during Stage 2: RESEARCH, each EvidenceItem carries its source's EvidenceScope. During Stage 3: CLUSTER BOUNDARIES, compatible EvidenceScopes are grouped into ClaimBoundaries.

**Secondary Use**: Source reliability calibration and verdict explanation

EvidenceScope helps users understand WHY evidence was weighted a certain way and which methodological frame it belongs to.

=== 2.3 When to Use EvidenceScope ===

**ALWAYS use EvidenceScope** (it's mandatory):

|= Scenario |= Example (Generic)
| **Source uses specific methodology** | "Standard S analysis" (vs "Framework F analysis")
| **Source has temporal boundaries** | "Period P data" (vs "Period Q historical data")
| **Source has system boundaries** | "Full system boundary" (vs "Subsystem only")
| **Source has geographic boundaries** | "Jurisdiction J regulations" (vs "Region R standards")
| **Source type affects reliability** | Peer-reviewed study vs organization report

**Every evidence source has**:
* A methodology (even an opinion uses "editorial commentary")
* A temporal anchor (at minimum the publication date)
* Optional boundaries and geographic scope

=== 2.4 EvidenceScope Examples ===

==== Example 1: Methodological Scope ====

**Input**: "Process X is more effective than Process Y"

**Evidence with EvidenceScope**:
{{code language="typescript"}}
{
  id: "EV_001",
  statement: "Study using Methodology A found Process X efficiency at Value V1",
  category: "statistic",
  sourceUrl: "https://source.example/study-1",
  sourceExcerpt: "Using Methodology A including phases 1-3...",
  evidenceScope: {
    name: "Methodology A Analysis",
    methodology: "Standard S with Approach A",
    temporal: "Period P data (Year-Year)",
    boundaries: "Phases 1-3 included",
    sourceType: "peer_reviewed_study"
  },
  scopeQuality: "complete",
  claimBoundaryId: "CB_01",  // Assigned during clustering
  relevantClaimIds: ["AC_01"],
  isDerivative: false
}
{{/code}}

**Why EvidenceScope?**:
* Methodology (Standard S) is metadata about the source
* Helps cluster with other evidence using same/compatible methodology
* Mandatory — cannot skip

==== Example 2: Geographic Regulatory Boundaries ====

**Input**: "Entity A violated regulations"

**Evidence with EvidenceScope**:
{{code language="typescript"}}
{
  id: "EV_002",
  statement: "Entity A's metric exceeded permitted limit by N%",
  category: "statistic",
  sourceUrl: "https://regulatory-body.example/report",
  sourceExcerpt: "Agency audit found Entity A exceeded the Jurisdiction J limit...",
  evidenceScope: {
    name: "Jurisdiction J Regulations",
    methodology: "Regulatory audit, Framework F",
    temporal: "Audit conducted Period P",
    boundaries: "Jurisdiction J only",
    geographic: "Region R",
    sourceType: "government_report"
  },
  scopeQuality: "complete"
}
{{/code}}

**Why EvidenceScope?**:
* Geography (Jurisdiction J) affects interpretation
* Clusters with other Jurisdiction J evidence
* Separates from Jurisdiction K evidence (different regulatory framework)

==== Example 3: Temporal Data Boundaries ====

**Input**: "Trend T is accelerating"

**Evidence with EvidenceScope**:
{{code language="typescript"}}
{
  id: "EV_003",
  statement: "Metric M increased by N units from Period P to Period Q",
  category: "statistic",
  sourceUrl: "https://data.example/records",
  sourceExcerpt: "Data records show N-unit increase over Period P-Q...",
  evidenceScope: {
    name: "Period P-Q Data Records",
    methodology: "Measurement Standard S",
    temporal: "Period P to Period Q timeframe",
    boundaries: "Metric M measurement boundary",
    sourceType: "government_report"
  },
  scopeQuality: "complete"
}
{{/code}}

**Why EvidenceScope?**:
* Temporal boundary (Period P-Q) is metadata about the measurement
* Helps assess temporal consistency across evidence
* Mandatory field

----

== 3. ClaimBoundary ==

=== 3.1 Definition ===

**ClaimBoundary** = An **evidence-emergent grouping** of compatible EvidenceScopes created AFTER research by clustering evidence with congruent methodology, temporal, boundaries, and geographic dimensions.

**Location**: Top-level in analysis result, created during Stage 3: CLUSTER BOUNDARIES

{{code language="typescript"}}
interface ClaimBoundary {
  id: string;                    // E.g., "CB_01", "CB_02"
  name: string;                  // E.g., "Methodology A Studies"
  shortName: string;             // E.g., "Method A"
  description: string;           // What this boundary represents
  methodology?: string;          // Dominant methodology (if applicable)
  boundaries?: string;           // Scope boundaries
  geographic?: string;           // Geographic scope
  temporal?: string;             // Temporal scope
  internalCoherence: number;     // 0-1: consistency of evidence within
  evidenceCount: number;         // Number of evidence items
}
{{/code}}

=== 3.2 Purpose ===

**Primary Use**: Organize evidence for verdict generation

ClaimBoundaries provide analytical structure for Stage 4: VERDICT. Each ClaimVerdict includes per-boundary findings (##BoundaryFinding[]##) showing how evidence within each boundary supports or contradicts each claim.

**Key principle**: Evidence tells us what boundaries exist. We don't guess.

=== 3.3 When ClaimBoundaries Are Created ===

**Boundaries emerge from evidence** (NOT from user input):

|= Scenario |= Result
| **Compatible EvidenceScopes** | Cluster into single ClaimBoundary
| **Incompatible methodologies** | Separate ClaimBoundaries (e.g., "Method A" vs "Method B")
| **Different jurisdictions** | Separate ClaimBoundaries (e.g., "Jurisdiction J" vs "Jurisdiction K")
| **Different temporal periods** | May separate if temporal is primary subject
| **Low internal coherence** | May split if evidence contradicts due to scope differences

**Clustering criteria** (LLM-evaluated during Stage 3):

| Factor | Merge if... | Separate if... |
|--------|------------|---------------|
| Methodology | Same or compatible methodology | Fundamentally different approach |
| Boundaries | Overlapping scope boundaries | Non-overlapping system boundaries |
| Geographic | Same or overlapping regions | Distinct jurisdictions with different rules |
| Temporal | Overlapping time periods | Non-overlapping periods with policy changes |
| Contradiction | Low contradiction between items | High contradiction driven by scope differences |

=== 3.4 ClaimBoundary Examples ===

==== Example 1: Methodological Split ====

**Input**: "Process X is more effective than Process Y"

**EvidenceScopes** (after research):
* 5 evidence items using "Methodology A, Full system"
* 3 evidence items using "Methodology B, Subsystem only"

**ClaimBoundaries** (after clustering):
{{code language="typescript"}}
[
  {
    id: "CB_01",
    name: "Methodology A Studies (Full System)",
    shortName: "Method A",
    description: "Evidence using Methodology A with full system boundary",
    methodology: "Methodology A",
    boundaries: "Full system boundary",
    internalCoherence: 0.92,
    evidenceCount: 5
  },
  {
    id: "CB_02",
    name: "Methodology B Studies (Subsystem)",
    shortName: "Method B",
    description: "Evidence using Methodology B with subsystem boundary",
    methodology: "Methodology B",
    boundaries: "Subsystem boundary",
    internalCoherence: 0.88,
    evidenceCount: 3
  }
]
{{/code}}

**Why separate ClaimBoundaries?**:
* **Different methodologies** (A vs B)
* **Different system boundaries** (full vs subsystem)
* **Cannot meaningfully combine** into single verdict without losing information
* **Each boundary gets its own finding** in ClaimVerdict.boundaryFindings[]

==== Example 2: Geographic Split ====

**Input**: "Entity A violated regulations"

**EvidenceScopes** (after research):
* 4 evidence items from "Jurisdiction J, Framework F"
* 2 evidence items from "Jurisdiction K, Framework G"

**ClaimBoundaries** (after clustering):
{{code language="typescript"}}
[
  {
    id: "CB_01",
    name: "Jurisdiction J Proceedings",
    shortName: "Jurisdiction J",
    description: "Evidence from Jurisdiction J regulatory framework",
    methodology: "Framework F",
    geographic: "Jurisdiction J",
    internalCoherence: 0.95,
    evidenceCount: 4
  },
  {
    id: "CB_02",
    name: "Jurisdiction K Proceedings",
    shortName: "Jurisdiction K",
    description: "Evidence from Jurisdiction K regulatory framework",
    methodology: "Framework G",
    geographic: "Jurisdiction K",
    internalCoherence: 0.90,
    evidenceCount: 2
  }
]
{{/code}}

**Why separate ClaimBoundaries?**:
* **Different jurisdictions** (J vs K)
* **Different regulatory frameworks** (F vs G)
* **May have different outcomes** (violation in J, not in K)
* **Need separate per-boundary findings**

==== Example 3: Single Boundary (Compatible Evidence) ====

**Input**: "Trend T is accelerating"

**EvidenceScopes** (after research):
* All 8 evidence items use "Standard S, Period P-Q data, Measurement Boundary B"

**ClaimBoundaries** (after clustering):
{{code language="typescript"}}
[
  {
    id: "CB_01",
    name: "General Evidence (Standard S)",
    shortName: "General",
    description: "All evidence uses compatible Standard S methodology with Period P-Q data",
    methodology: "Standard S",
    temporal: "Period P-Q",
    boundaries: "Measurement Boundary B",
    internalCoherence: 0.93,
    evidenceCount: 8
  }
]
{{/code}}

**Why single ClaimBoundary?**:
* **All evidence compatible** (same standard, same period, same boundaries)
* **No meaningful split needed**
* **Default case for most analyses**

----

== 4. Decision Tree ==

{{code}}
Evidence Item Extracted
│
├─ ALWAYS assign EvidenceScope (MANDATORY)
│  ├─ methodology: "Standard S with Approach A" (REQUIRED)
│  ├─ temporal: "Period P data" (REQUIRED)
│  ├─ boundaries: "Full system" (optional)
│  └─ geographic: "Region R" (optional)
│
└─ After ALL evidence extracted → Stage 3: CLUSTER BOUNDARIES
   │
   ├─ Are EvidenceScopes COMPATIBLE?
   │  ├─ YES (same/compatible methodology + temporal + boundaries)
   │  │   → Cluster into SINGLE ClaimBoundary
   │  │   Examples:
   │  │   - All sources use Standard S, Period P
   │  │   - Compatible methodologies with overlapping boundaries
   │  │
   │  └─ NO (incompatible methodology OR boundaries OR temporal OR geographic)
   │      → Create SEPARATE ClaimBoundaries
   │      Examples:
   │      - Standard S (full system) vs Standard T (subsystem)
   │      - Jurisdiction J vs Jurisdiction K
   │      - Period P vs Period Q (if temporal is primary subject)
{{/code}}

=== Decision Checklist ===

**For EvidenceScope (every evidence item)**:
* Did I assign methodology? (REQUIRED)
* Did I assign temporal? (REQUIRED)
* Are boundaries/geographic relevant for this source? (optional but recommended)
* Is scopeQuality "complete", "partial", or "incomplete"?

**For ClaimBoundary (pipeline-determined)**:
* Let the LLM cluster compatible EvidenceScopes (don't pre-create boundaries from input)
* Trust the congruence assessment (methodology + temporal + boundaries + geographic)
* Expect 1-3 boundaries (typical), max 5 (rare)

----

== 5. Common Mistakes ==

=== Mistake 1: Skipping EvidenceScope ===

**Wrong**:
{{code language="typescript"}}
// Evidence without EvidenceScope
evidenceItems: [
  {
    id: "EV_001",
    statement: "Source found Value V",
    // evidenceScope: undefined  ❌ MISSING - will fail validation
  }
]
{{/code}}

**Problem**: EvidenceScope is MANDATORY in ClaimBoundary pipeline. Cannot skip.

**Correct**:
{{code language="typescript"}}
evidenceItems: [
  {
    id: "EV_001",
    statement: "Source found Value V",
    evidenceScope: {
      name: "Source Methodology",
      methodology: "Standard S",
      temporal: "Period P data",
    },
    scopeQuality: "complete"
  }
]
{{/code}}

=== Mistake 2: Pre-Creating ClaimBoundaries from Input ===

**Wrong**:
{{code language="typescript"}}
// Input: "Process X vs Process Y"
// Manually creating ClaimBoundaries BEFORE research
claimBoundaries: [
  { name: "Process X Analysis" },  ❌ DON'T pre-create
  { name: "Process Y Analysis" },  ❌ DON'T pre-create
]
{{/code}}

**Problem**: ClaimBoundaries are NOT pre-created. They emerge from evidence EvidenceScopes during Stage 3.

**Correct**:
{{code language="typescript"}}
// Input: "Process X vs Process Y"
// Extract AtomicClaims during Stage 1
atomicClaims: [
  { statement: "Process X achieves Metric M at Value V1" },
  { statement: "Process Y achieves Metric M at Value V2" }
]

// Research during Stage 2 (gather evidence with EvidenceScopes)
evidenceItems: [
  {
    statement: "Study using Method A found Process X at V1",
    evidenceScope: { methodology: "Method A", temporal: "Period P" },
    relevantClaimIds: ["AC_01"]
  },
  {
    statement: "Study using Method B found Process Y at V2",
    evidenceScope: { methodology: "Method B", temporal: "Period P" },
    relevantClaimIds: ["AC_02"]
  }
]

// Cluster boundaries during Stage 3 (IF methodologies are incompatible)
claimBoundaries: [
  { id: "CB_01", name: "Method A Studies", evidenceCount: ...},
  { id: "CB_02", name: "Method B Studies", evidenceCount: ...}
]
// OR cluster into single boundary if methodologies are compatible
{{/code}}

=== Mistake 3: Using Source Name as EvidenceScope ===

**Wrong**:
{{code language="typescript"}}
// Putting source name in EvidenceScope
evidenceScope: {
  name: "According to Source Entity",  ❌ This is just attribution
  methodology: "Source Entity study"  ❌ Source name is not methodology
}
{{/code}}

**Correct**:
{{code language="typescript"}}
// EvidenceScope is for METHODOLOGY, not source name
evidenceScope: {
  name: "Peer-Reviewed Assessment using Standard S",  ✅ Methodology-focused
  methodology: "Standard S with Approach A",  ✅ The analytical approach
  temporal: "Period P data",
  sourceType: "peer_reviewed_study"
}

// Source name goes in sourceTitle
sourceTitle: "Source Entity Publication"
{{/code}}

=== Mistake 4: Conflating EvidenceScope with ClaimBoundary ===

**Wrong thinking**:
"Each EvidenceScope becomes a ClaimBoundary"

**Problem**: Multiple evidence items share the same EvidenceScope, and compatible EvidenceScopes cluster into a SINGLE ClaimBoundary.

**Correct thinking**:
"Compatible EvidenceScopes cluster into ClaimBoundaries"

**Example**:
* 10 evidence items all have EvidenceScope: ##{ methodology: "Standard S", temporal: "Period P" }##
* These 10 items cluster into **1 ClaimBoundary** (not 10)
* ClaimBoundary name: "Standard S Studies (Period P)"

----

== 6. Code Examples ==

=== 6.1 Creating EvidenceScope (Stage 2: RESEARCH) ===

{{code language="typescript"}}
import type { EvidenceItem, EvidenceScope } from "@/lib/analyzer/types";

function extractEvidenceWithScope(source: Source, relevantClaims: AtomicClaim[]): EvidenceItem[] {
  const items: EvidenceItem[] = [];

  // Extract evidence statement
  const statement = extractStatementFromSource(source);

  // REQUIRED: Extract EvidenceScope metadata from source
  const scope: EvidenceScope = {
    name: detectScopeName(source),           // E.g., "Methodology A Analysis"
    methodology: detectMethodology(source),  // REQUIRED - never empty
    temporal: detectTemporal(source),        // REQUIRED - at minimum publication date
    boundaries: detectBoundaries(source),    // Optional - what's included/excluded
    geographic: detectGeographic(source),    // Optional - geographic scope
    sourceType: classifySourceType(source),  // Optional - peer_reviewed_study, etc.
  };

  // Assess scope quality
  const scopeQuality = assessScopeQuality(scope);

  items.push({
    id: generateId(source.id),
    statement: statement,
    category: categorizeEvidence(statement),
    sourceId: source.id,
    sourceUrl: source.url,
    sourceExcerpt: source.excerpt,
    evidenceScope: scope,  // MANDATORY
    scopeQuality: scopeQuality,
    relevantClaimIds: relevantClaims.map(c => c.id),
    isDerivative: detectDerivative(source),
  });

  return items;
}
{{/code}}

=== 6.2 Clustering ClaimBoundaries (Stage 3: CLUSTER BOUNDARIES) ===

{{code language="typescript"}}
import type { ClaimBoundary, EvidenceItem, EvidenceScope } from "@/lib/analyzer/types";

async function clusterBoundaries(
  evidenceItems: EvidenceItem[],
  atomicClaims: AtomicClaim[]
): Promise<ClaimBoundary[]> {
  // Collect all unique EvidenceScopes
  const scopes: EvidenceScope[] = collectUniqueScopes(evidenceItems);

  // LLM call: Cluster compatible EvidenceScopes into ClaimBoundaries
  const clusteringResult = await llm.clusterEvidenceScopes({
    scopes: scopes,
    evidenceItems: evidenceItems,
    atomicClaims: atomicClaims,
    congruenceGuidance: getCongruenceGuidance(),  // From architecture doc §11.5
  });

  // Assign evidence items to ClaimBoundaries
  for (const item of evidenceItems) {
    const boundaryId = clusteringResult.scopeToBoundaryMapping[item.evidenceScope.name];
    item.claimBoundaryId = boundaryId;
  }

  return clusteringResult.claimBoundaries;
}

function collectUniqueScopes(items: EvidenceItem[]): EvidenceScope[] {
  const uniqueScopes = new Map<string, EvidenceScope>();
  for (const item of items) {
    const scopeKey = `${item.evidenceScope.methodology}|${item.evidenceScope.temporal}|${item.evidenceScope.boundaries || ''}`;
    if (!uniqueScopes.has(scopeKey)) {
      uniqueScopes.set(scopeKey, item.evidenceScope);
    }
  }
  return Array.from(uniqueScopes.values());
}
{{/code}}

=== 6.3 Using ClaimBoundaries in Verdicts (Stage 4: VERDICT) ===

{{code language="typescript"}}
import type { ClaimVerdict, BoundaryFinding } from "@/lib/analyzer/types";

async function generateVerdicts(
  claims: AtomicClaim[],
  evidenceItems: EvidenceItem[],
  boundaries: ClaimBoundary[]
): Promise<ClaimVerdict[]> {
  const verdicts: ClaimVerdict[] = [];

  for (const claim of claims) {
    // Group evidence by ClaimBoundary for this claim
    const evidenceByBoundary = groupEvidenceByBoundary(
      evidenceItems.filter(e => e.relevantClaimIds.includes(claim.id)),
      boundaries
    );

    // LLM call: Generate verdict with per-boundary findings
    const verdictResult = await llm.advocateVerdict({
      claim: claim,
      evidenceByBoundary: evidenceByBoundary,
      boundaries: boundaries,
    });

    verdicts.push({
      id: generateVerdictId(claim.id),
      claimId: claim.id,
      truthPercentage: verdictResult.truthPercentage,
      verdict: verdictResult.verdict,
      confidence: verdictResult.confidence,
      reasoning: verdictResult.reasoning,
      boundaryFindings: verdictResult.boundaryFindings,  // Per-boundary assessments
      // ...
    });
  }

  return verdicts;
}
{{/code}}

----

== Appendix: Real-World Examples (Genericized) ==

=== Example A: Methodology Split ===

**Input**: "Process X is more effective than Process Y"

**Correct Approach**:
{{code language="typescript"}}
// TWO ClaimBoundaries (incompatible methodologies)
claimBoundaries: [
  { id: "CB_01", name: "Method A Studies (Full System)", methodology: "Method A" },
  { id: "CB_02", name: "Method B Studies (Subsystem)", methodology: "Method B" },
]

// Evidence with EvidenceScope (drives clustering)
evidenceItems: [
  {
    id: "EV_001",
    statement: "Study using Method A found Process X effectiveness at Value V1",
    evidenceScope: { methodology: "Method A", temporal: "Period P", boundaries: "Full system" },
    claimBoundaryId: "CB_01",  // Assigned during clustering
    relevantClaimIds: ["AC_01"]
  },
  {
    id: "EV_002",
    statement: "Study using Method B found Process Y effectiveness at Value V2",
    evidenceScope: { methodology: "Method B", temporal: "Period P", boundaries: "Subsystem" },
    claimBoundaryId: "CB_02",  // Assigned during clustering
    relevantClaimIds: ["AC_02"]
  },
]
{{/code}}

=== Example B: No Split Needed (Compatible Evidence) ===

**Input**: "Entity A's action was appropriate"

**Correct Approach**:
{{code language="typescript"}}
// ONE ClaimBoundary (all evidence compatible)
claimBoundaries: [
  { id: "CB_01", name: "General Evidence", methodology: "Standard S", evidenceCount: 5 },
]

// Evidence with compatible EvidenceScopes (cluster into single boundary)
evidenceItems: [
  {
    id: "EV_001",
    statement: "Source A assessed action as appropriate using Standard S",
    evidenceScope: { methodology: "Standard S", temporal: "Period P" },
    claimBoundaryId: "CB_01"
  },
  {
    id: "EV_002",
    statement: "Source B confirmed appropriateness using Standard S",
    evidenceScope: { methodology: "Standard S", temporal: "Period P" },
    claimBoundaryId: "CB_01"
  },
  // All 5 items cluster into CB_01
]
{{/code}}

----

**Document Version**: 3.0.0-cb
**Last Updated**: 2026-02-16
**Next Review**: After ClaimBoundary pipeline UI implementation
**Maintained by**: Technical Writer
