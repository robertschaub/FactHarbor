= System Design =

FactHarbor uses a **two-service architecture**: a Next.js web application (UI + AKEL analysis engine) and a .NET API (job management + persistence). Both services run on a single host and communicate via HTTP.

== Two-Service Architecture ==

{{include reference="FactHarbor.Product Development.Diagrams.System Architecture.WebHome"/}}

//The Next.js app serves the UI and runs the AKEL analysis engine. The .NET API manages job persistence, status tracking, and event streaming. Both access separate SQLite databases; the .NET API triggers the analysis engine via HTTP.//

=== Why Two Services? ===

* **.NET API** handles what it does best: structured data persistence (Entity Framework Core), job lifecycle management, and Server-Sent Events (SSE) for real-time updates
* **Next.js** handles what it does best: React UI rendering, TypeScript analysis logic, and the Vercel AI SDK for LLM orchestration
* Each service can be developed, tested, and deployed independently
* The .NET API could be replaced with any backend that implements the same REST contract

== Request Lifecycle ==

{{include reference="FactHarbor.Product Development.Diagrams.Request Lifecycle.WebHome"/}}

//A user submits input, the .NET API queues a job and triggers the analysis runner. The AKEL pipeline runs asynchronously, and results are streamed back to the user via Server-Sent Events.//

=== Key Communication Contracts ===

|= Endpoint |= Direction |= Purpose
| ##POST /v1/analyze## | Next.js → .NET | Create a new analysis job
| ##GET /v1/jobs/{id}## | Next.js → .NET | Retrieve job status and results
| ##GET /v1/jobs/{id}/events## | Next.js → .NET | SSE stream of job progress events
| ##POST /api/internal/run-job## | .NET → Next.js | Trigger AKEL pipeline execution (with exponential backoff + jitter retry)
| ##PATCH /v1/internal/jobs/{id}## | Next.js → .NET | Update job status and save results

== Technology Stack ==

{{include reference="FactHarbor.Product Development.Diagrams.Technology Stack.WebHome"/}}

//The technology stack is organised in layers: UI (React/Next.js), Engine (TypeScript/AI SDK), API (.NET/EF Core), Storage (SQLite), and External Services (LLM + search providers with specific model versions).//

== Service Responsibilities ==

=== Next.js Web App ===

|= Area |= Responsibility |= Key Files
| **UI Pages** | Analysis submission, job results, admin dashboard | ##src/app/analyze/##, ##src/app/jobs/##, ##src/app/admin/##
| **Proxy API Routes** | Forward requests to .NET API | ##src/app/api/fh/##
| **AKEL Pipeline** | Full fact-checking analysis (Understand → Research → Verdict → Report) | ##src/lib/analyzer/orchestrated.ts##
| **Shared Modules** | Evidence filtering, aggregation, quality gates, source reliability | ##src/lib/analyzer/*.ts##
| **Configuration (UCM)** | Runtime config management with versioning and validation | ##src/lib/config-*.ts##
| **Provider Health** | Circuit breaker per provider, auto-pause, webhook notifications | ##src/lib/provider-health.ts##

=== .NET API ===

|= Area |= Responsibility |= Key Files
| **Job Management** | CRUD operations, status tracking, progress updates | ##Controllers/JobsController.cs##
| **Analysis Trigger** | Invoke the AKEL runner with exponential backoff retry | ##Services/RunnerClient.cs##
| **Event Streaming** | SSE (Server-Sent Events) for real-time job progress | ##Controllers/JobsController.cs##
| **System Health** | Health checks, system health proxy to runner | ##Controllers/SystemHealthController.cs##
| **Persistence** | SQLite via Entity Framework Core, migrations | ##Data/FhDbContext.cs##

----

**Navigation:** [[Architecture>>FactHarbor.Product Development.Specification.Architecture.WebHome]] | Next: [[AKEL Pipeline>>FactHarbor.Product Development.Specification.Architecture.AKEL Pipeline.WebHome]]
